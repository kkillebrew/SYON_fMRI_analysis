# HM edited to handle no retExp 20220708

#!/bin/tcsh -xef

echo "auto-generated by afni_proc.py, Tue Feb 27 13:07:01 2018"
echo "(version 5.11, December 29, 2016)"
echo "execution started: `date`"

# execute and save run log via : 
#   tcsh -xef proc.sh S####### |& tee output.proc.S#######.txt

# =========================== auto BLOCK4: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 23 Sep 2016
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 23 Sep 2016)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

# the user may specify a single subject to run with
if ( $#argv > 0 ) then
    set subj = $argv[1]
else
    echo "Please set subject ID as input variable"
    exit
endif

# assign 7T QA dir
set proc_dir = /home/jaco-raid8/sponheim-data/SYON/fMRI_preproc
set git_regress_dir = /home/jaco-raid8/sponheim-data/SYON/SYON_fMRI_analysis.git/regressors

# assign output directory name
set output_dir = {$proc_dir}/{$subj}/preproc_data

# verify that the results directory does not yet exist
if ( -d $output_dir ) then
    echo output dir "$output_dir" already exists
    exit
endif

# set list of runs; HM updating to 11 (no retExp)
set runs = (`count -digits 2 1 11`)

# create results and stimuli directories
mkdir $output_dir
mkdir $output_dir/stimuli
mkdir $output_dir/files_ACF
mkdir $output_dir/files_ClustSim
mkdir $output_dir/regressors # different than in pHCP, put regressors files in a sub-folder inside
# the pre-proc data dir, rather than along side -- mps 20200818

#check if surface volume exists 
if (-d /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj/SUMA ) then
    ln -s                                                                      \
    /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj/SUMA/anat_SurfVol.nii.gz \
    $output_dir/
else 

#create surface volume
    @SUMA_Make_Spec_FS -fspath /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj -sid anat

    3dcopy /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj/SUMA/anat_SurfVol+orig \
       /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj/SUMA/anat_SurfVol.nii.gz

# link anatomy to results dir
    ln -s                                                                      \
    /home/jaco-raid8/sponheim-data/SYON/FreeSurfer/$subj/SUMA/anat_SurfVol.nii.gz \
    $output_dir/
endif

3dSkullStrip -prefix $output_dir/anat_SurfVol_ns -input $output_dir/anat_SurfVol.nii.gz -orig_vol
3dUnifize -prefix $output_dir/anat_SurfVol_ns_uni -input $output_dir/anat_SurfVol_ns+orig -GM

# will extract automatic -blip_forward_dset in tcat BLOCK4, below

set data_dir = /home/jaco-raid8/sponheim-data/SYON/fMRI_preproc/$subj/converted_data

# copy external -blip_reverse_dset dataset
3dTcat -prefix $output_dir/blip_reverse \
    {$data_dir}/oppPE.nii.gz

# ============================ auto BLOCK4: tcat ============================
# apply 3dTcat to copy input dsets to results dir, while
# removing the first 0 TRs
3dTcat -prefix $output_dir/pb00.$subj.r01.tcat \
    {$data_dir}/retCW.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r02.tcat \
    {$data_dir}/retCCW.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r03.tcat \
    {$data_dir}/gamLoc.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r04.tcat \
    {$data_dir}/ssLoc.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r05.tcat \
    {$data_dir}/illLoc.nii'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r06.tcat \
    {$data_dir}/sizeHall_LL.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r07.tcat \
    {$data_dir}/sizeHall_UL.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r08.tcat \
    {$data_dir}/sizeNoHall_LL.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r09.tcat \
    {$data_dir}/sizeNoHall_UL.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r10.tcat \
    {$data_dir}/LOCLoc.nii.gz'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r11.tcat \
    {$data_dir}/MTLoc.nii.gz'[0..$]'
#3dTcat -prefix $output_dir/pb00.$subj.r12.tcat \
#    {$data_dir}/retExp.nii.gz'[0..$]'

# and make note of repetitions (TRs) per run
# HM updating for this person (no retExp)
set tr_counts = ( 255 255 263 313 313 163 163 163 163 255 255 )

# -------------------------------------------------------
# enter the results directory (can begin processing data)
cd $output_dir

# ========================== auto BLOCK4: outcount ==========================
# data check: compute outlier fraction for each volume
touch out.pre_ss_warn.txt
foreach run ( $runs )
    3dToutcount -automask -fraction -polort 4 -legendre                     \
                pb00.$subj.r$run.tcat+orig > outcount.r$run.1D

    # outliers at TR 0 might suggest pre-steady state TRs
    if ( `1deval -a outcount.r$run.1D"{0}" -expr "step(a-0.4)"` ) then
        echo "** TR #0 outliers: possible pre-steady state TRs in run $run" \
            >> out.pre_ss_warn.txt
    endif
end

# catenate outlier counts into a single time series
cat outcount.r*.1D > outcount_rall.1D

# ================================= tshift =================================
# time shift data so all slice timing is the same 
foreach run ( $runs )
    3dTshift -tzero 0 -quintic -prefix pb01.$subj.r$run.tshift pb00.$subj.r$run.tcat+orig
end

# can't do 3dTshift for oppPE, because AFNI requires minimum 5 TRs...

# ================================= grad unwarp ==================================
# mps 20181019 moved this before volreg

3dbucket -prefix gu_base pb01.$subj.r01.tshift+orig"[2]"
3dcopy gu_base+orig gu_base.nii.gz

gradient_unwarp.py gu_base.nii.gz grad_unwarp.nii.gz siemens -g                                              \
    /home/shaw-raid1/sponheim-data/python_tools/gradunwarp-1.0.3/coef/3TB_coeff_from_scanner_20200306.grad -n

minn.py makeFullWarpRel -f fullWarp_abs.nii.gz

# mps 20181019 need to apply now, so we can have rm files with GU...
foreach run ($runs)
    3dNwarpApply                             \
        -source pb01.$subj.r$run.tshift+orig \
        -nwarp "fullWarp_rel.nii.gz"         \
        -prefix rm.$subj.r$run.gu+orig
end

3dNwarpApply                             \
    -source blip_reverse+orig            \
    -nwarp "fullWarp_rel.nii.gz"         \
    -prefix rm.blip_reverse.gu+orig


# ================================= volreg =================================
# align each dset to base volume, blip warp, align to anat
# (final warp input is same as blip input)

# extract volreg registration base
# mps 20181019 change this to use the gu file we just made, rather than tshift
3dbucket -prefix vr_base rm.$subj.r01.gu+orig"[2]"

# register and warp
foreach run ( $runs )
    # register each volume to the base
    3dvolreg -verbose -zpad 1 -base vr_base+orig                          \
             -1Dfile dfile.r$run.1D -prefix rm.epi.volreg.r$run           \
             -cubic                                                       \
             -1Dmatrix_save mat.r$run.vr.aff12.1D                         \
             rm.$subj.r$run.gu+orig
end

# mps 20181019 might as well do motion correction for opp PE while we're at it, hope we don't need it!
3dvolreg -verbose -zpad 1                \
         -prefix blip_reverse.vr+orig \
         -cubic                          \
         rm.blip_reverse.gu+orig


# make a single file of registration params
cat dfile.r*.1D > dfile_rall.1D


# ================================== blip ==================================
# apply blip up/down non-linear alignment to EPI

# -------------------------------------------------------
# extract initial volumes as automatic -blip_forward_dset
# mps 20181019 use the volreg file above here for blip forward
3dTcat -prefix blip_forward.vr rm.epi.volreg.r01+orig"[0..2]"

# create median datasets from forward and reverse time series
3dTstat -median -prefix rm.blip.med.fwd blip_forward.vr+orig
3dTstat -median -prefix rm.blip.med.rev blip_reverse.vr+orig

# automask the median datasets 
3dAutomask -apply_prefix rm.blip.med.masked.fwd rm.blip.med.fwd+orig
3dAutomask -apply_prefix rm.blip.med.masked.rev rm.blip.med.rev+orig

# compute the midpoint warp between the median datasets
3dQwarp -plusminus -pmNAMES Rev For                           \
        -pblur 0.05 0.05 -blur -1 -1                          \
        -noweight -minpatch 9                                 \
        -source rm.blip.med.masked.rev+orig                   \
        -base   rm.blip.med.masked.fwd+orig                   \
        -prefix blip_warp


# ================================= align ==================================
# create align_base 
# mps 20181019 remove GU from this step, because we already applied it

3dNwarpApply                         \
    -source vr_base+orig             \
    -nwarp "blip_warp_For_WARP+orig" \
    -prefix align_base

#3dUnifize -prefix align_base_uni -input align_base+orig -T2
# mps & tes decided not unifize back in spring 2018, because it was not helping

# for e2a: compute anat alignment transformation to EPI registration base
# (new anat will be intermediate, stripped, anat_SurfVol_ns+orig)
align_epi_anat.py -epi2anat -anat anat_SurfVol_ns+orig \
        -suffix _al                                    \
        -epi align_base+orig                           \
        -epi_base 0                                    \
        -epi_strip 3dAutomask                          \
        -ginormous_move                                \
        -volreg off                                    \
        -tshift off                                    \
        -cost lpc+ZZ                                   \
        -anat_has_skull no
# mps 20181019 switching to lpc+ZZ from lpc because it's supposed to be better...

foreach run ($runs)
     #catenate blip/volreg/epi2anat xforms
#    cat_matvec -ONELINE                          \
#        align_base_al_mat.aff12.1D          \
#        mat.r$run.vr.aff12.1D > mat.r$run.warp.1D

    # apply catenated xform: blip/volreg/epi2anat/NLtlrc
    # then apply non-linear standard-space warp

    3dNwarpApply                                                                                                   \
        -source pb01.$subj.r$run.tshift+orig                                                                       \
        -master anat_SurfVol_ns+orig                                                                               \
        -newgrid 2                                                                                                 \
        -nwarp "align_base_al_mat.aff12.1D blip_warp_For_WARP+orig mat.r$run.vr.aff12.1D fullWarp_rel.nii.gz" \
        -prefix pb02.$subj.r$run.volreg+orig
# mps 20181019 renaming .align back to .volreg so that afni knows what to do with it later when making out.ss.review

    3dZeropad -overwrite -R -12 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -L -12 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -A -12 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -P -12 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -S -20 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -I -16 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig
    # @@@ MPS 20200313 CHECK ZERO PAD -- LIKELY INCORRECT!!!!!

    3dcalc -overwrite -prefix pb02.$subj.r$run.volreg+orig -a pb02.$subj.r$run.volreg+orig -expr 'a' -datum short
     
    # create an all-1 dataset to mask the extents of the warp
     3dcalc -overwrite -a pb02.$subj.r$run.volreg+orig -expr 'step(a)'               \
           -prefix rm.epi.all1

#warp the all-1 dataset for extents masking 
#    3dAllineate -base anat_SurfVol_ns+orig                                \
#                -input rm.epi.all1+orig                                   \
#                -1Dmatrix_apply mat.r$run.warp.1D                   \
#                -mast_dxyz 1.6 -final NN -quiet                 \
#                -prefix rm.epi.1.r$run+orig

#       3dZeropad -overwrite -R -15 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig 
#   3dZeropad -overwrite -L -15 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig 
#   3dZeropad -overwrite -A -15 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig 
#   3dZeropad -overwrite -P -15 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig     
#   3dZeropad -overwrite -S -40 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig 
#   3dZeropad -overwrite -I -20 -prefix rm.epi.1.r$run+orig rm.epi.1.r$run+orig 

# make an extents intersection mask of this run
    3dTstat -min -prefix rm.epi.min.r$run rm.epi.all1+orig
end
# ----------------------------------------


# create the extents mask: mask_epi_extents+orig
# (this is a mask of voxels that have valid data at every TR)
3dMean -datum short -prefix rm.epi.mean rm.epi.min.r*.HEAD 
3dcalc -a rm.epi.mean+orig -expr 'step(a-0.999)' -prefix mask_epi_extents

# and apply the extents mask to the EPI data 
# (delete any time series with missing data)
foreach run ( $runs )
    3dcalc -a pb02.$subj.r$run.volreg+orig -b mask_epi_extents+orig           \
           -expr 'a*b' -prefix pb03.$subj.r$run.masked
end

# warp the volreg base EPI dataset to make a final version
cat_matvec -ONELINE anat_SurfVol_ns_al_e2a_only_mat.aff12.1D -I  >               \
    mat.basewarp.aff12.1D

3dAllineate -base anat_SurfVol_ns+orig                                    \
            -input vr_base+orig                                           \
            -1Dmatrix_apply mat.basewarp.aff12.1D                         \
            -mast_dxyz 1.6                                                \
            -prefix final_epi_vr_base

# create an anat_final dataset, aligned with stats
3dcopy anat_SurfVol_ns+orig anat_final.$subj

# record final registration costs
3dAllineate -base final_epi_vr_base+orig -allcostX                        \
            -input anat_final.$subj+orig |& tee out.allcostX.txt

# -----------------------------------------
# warp anat follower datasets (identity: resample)



# ================================== blur ==================================
# blur each volume of each run
foreach run ( $runs )
    3dmerge -1blur_fwhm 2.0 -doall -prefix pb04.$subj.r$run.blur \
            pb03.$subj.r$run.masked+orig
end

# ================================== mask ==================================
# create 'full_mask' dataset (union mask)
foreach run ( $runs )
    3dAutomask -dilate 1 -prefix rm.mask_r$run pb04.$subj.r$run.blur+orig
end

# create union of inputs, output type is byte
3dmask_tool -inputs rm.mask_r*+orig.HEAD -union -prefix full_mask.$subj

# ---- create subject anatomy mask, mask_anat.$subj+orig ----
#      (resampled from aligned anat)
3dresample -master full_mask.$subj+orig -input anat_SurfVol_ns_uni+orig  \
           -prefix rm.resam.anat

# convert to binary anat mask; fill gaps and holes
3dmask_tool -dilate_input 5 -5 -fill_holes -input rm.resam.anat+orig \
            -prefix mask_anat.$subj

# compute overlaps between anat and EPI masks
3dABoverlap -no_automask full_mask.$subj+orig mask_anat.$subj+orig   \
            |& tee out.mask_ae_overlap.txt

# note Dice coefficient of masks, as well
3ddot -dodice full_mask.$subj+orig mask_anat.$subj+orig              \
      |& tee out.mask_ae_dice.txt

# ================================= scale ==================================
# scale each voxel time series to have a mean of 100
# (be sure no negatives creep in)
# (subject to a range of [0,200])
foreach run ( $runs )
    3dTstat -prefix rm.mean_r$run pb04.$subj.r$run.blur+orig
    3dcalc -a pb04.$subj.r$run.blur+orig -b rm.mean_r$run+orig \
           -c mask_epi_extents+orig                            \
           -expr 'c * min(200, a/b*100)*step(a)*step(b)'       \
           -prefix pb05.$subj.r$run.scale
end

# ================================ regress =================================

foreach run ( $runs ) # e.g., 01, 02...

    set scale_list = 'pb05.'{$subj}'.r'{$run}'.scale+orig.HEAD'
    set tcat_list = 'pb00.'{$subj}'.r'{$run}'.tcat+orig.HEAD'

    if ( ($run == 01) || ($run == 02) || ($run == 10) || ($run == 11) ) then
        set n_TRs = 255
        if ($run == 01) then
            set task_name_uppercase = 'retCW'
        else if ($run == 02) then
            set task_name_uppercase = 'retCCW'
        else if ($run == 10) then
            set task_name_uppercase = 'LOCLoc'
            set condA_name = 'intact'
            set condB_name = 'scrambled'
        else if ($run == 11) then
            set task_name_uppercase = 'MTLoc'
            set condA_name = 'moving'
            set condB_name = 'static'
#        else if ($run == 12) then
#            set task_name_uppercase = 'retExp'
        else
            echo 'unknown run number..? #1'
        endif
        set n_goforit = 0
    else if ( $run == 03 ) then
        set n_TRs = 263
        set task_name_uppercase = 'gamLoc'
        set n_goforit = 0
                # allow for X errors / warnings, which is how many we get for pRF because the auditory task timing is not independent enough...
    else if ( ($run == 04) || ($run == 05) ) then
        set n_TRs = 313
        if ($run == 04) then
            set task_name_uppercase = 'ssLoc'
            set condA_name = 'center'
            set condB_name = 'surround'
        else if ($run == 05) then
            set task_name_uppercase = 'illLoc'
            set condA_name = 'inducer'
            set condB_name = 'contour'
        else
            echo 'unknown run number..? #2'
        endif
        set n_goforit = 0
                # allow for X errors / warnings, which is how many we get for pRF because the auditory task timing is not independent enough...
    else if ( ($run == 06) || ($run == 07) || ($run == 08) || ($run == 09) ) then
        set n_TRs = 163
        if ($run == 06) then
            set task_name_uppercase = 'sizeHall_LL'
        else if ($run == 07) then
            set task_name_uppercase = 'sizeHall_UL'
        else if ($run == 08) then
            set task_name_uppercase = 'sizeNoHall_LL'
        else if ($run == 09) then
            set task_name_uppercase = 'sizeNoHall_UL'
        else
            echo 'unknown run number..? #3'
        endif
        set n_goforit = 0 
    else
            echo 'unknown run number..? #4'
    endif

    set which_task = $task_name_uppercase
    set idx_runs = 1 # only 1 run in each condition...

    # touch dfile_{$which_task}.1D
    # touch outcount_{$which_task}.1D

    # foreach which_runs ( $use_runs )
    #     cat dfile.r0{$which_runs}.1D >> dfile_{$which_task}.1D
    #     cat outcount.r0{$which_runs}.1D >> outcount_{$which_task}.1D
    # end

# compute de-meaned motion parameters (for use in regression)
    1d_tool.py -infile dfile.r{$run}.1D -set_run_lengths  $n_TRs \
        -demean -write motion_demean_{$which_task}.1D

# compute motion parameter derivatives (just to have)
     1d_tool.py -infile dfile.r{$run}.1D -set_run_lengths  $n_TRs \
           -derivative -demean -write motion_deriv_{$which_task}.1D

# create censor file motion_${subj}_censor.1D, for censoring motion 
     1d_tool.py -infile dfile.r{$run}.1D -set_run_lengths  $n_TRs \
    -show_censor_count -censor_prev_TR                             \
    -censor_motion 0.5 motion_${subj}_{$which_task}

    # note TRs that were not censored
    set ktrs = `1d_tool.py -infile motion_${subj}_{$which_task}_censor.1D \
                           -show_trs_uncensored encoded`

# # add regressors
	# HM changing below to account for no retExp 20220708
    if ( ($run == 01) || ($run == 02) ) then
        # no task regressors here, fourier analysis of Ret data
        set n_cond = 0
        set stim_file_reg = ""
        set glt_reg = ""

    else if ( $run == 03 ) then # gamma loc
        set n_cond = 1

        cp {$git_regress_dir}/{$task_name_uppercase}.1D regressors/{$task_name_uppercase}.1D

        set stim_file_reg = "-stim_times 1 regressors/"{$task_name_uppercase}".1D 'BLOCK4(10,1)' -stim_label 1 circle"
        set glt_reg = ""

    else if ( ( $run == 06 ) || ( $run == 07 ) || ( $run == 08 ) || ( $run == 09 ) ) then # size task
        set n_cond = 1

        cp {$git_regress_dir}/{$task_name_uppercase}.1D regressors/{$task_name_uppercase}.1D

        set stim_file_reg = "-stim_times 1 regressors/"{$task_name_uppercase}".1D 'BLOCK4(10,1)' -stim_label 1 present"
        set glt_reg = ""

    else if ( ($run == 04) || ($run == 05) || ($run == 10) || ($run == 11) ) then # ss loc, ill loc, LOCloc, MTloc
        set n_cond = 2

        cp {$git_regress_dir}/{$task_name_uppercase}_{$condA_name}.1D regressors/{$task_name_uppercase}_{$condA_name}.1D # center, inducer
        cp {$git_regress_dir}/{$task_name_uppercase}_{$condB_name}.1D regressors/{$task_name_uppercase}_{$condB_name}.1D # surround, contour

        set stim_file_reg = "-stim_times 1 regressors/"{$task_name_uppercase}"_"{$condA_name}".1D 'BLOCK4(10,1)' -stim_label 1 "{$condA_name}" -stim_times 2 regressors/"{$task_name_uppercase}"_"{$condB_name}".1D 'BLOCK4(10,1)' -stim_label 2 "{$condB_name}""
        # mps 20200828 -- model each block as 10 SECONDS
        set glt_reg = "-gltsym 'SYM: "{$condA_name}" - "{$condB_name}"' -glt_label 1 "{$condA_name}"_min_"{$condB_name}""

    else
        echo "Error: Unknown run value = "{$run}
        exit
     endif

    foreach add_me (1 2 3 4 5 6) # 6 motion params
        @ num_${add_me} = $add_me + $n_cond
    end
    @ num_ts = $n_cond + 6

# ------------------------------
# run the regression analysis
    echo "3dDeconvolve -input $scale_list"\
        "-censor motion_${subj}_${which_task}_censor.1D "\
        "-polort 'A' -float "\
        "-num_stimts $num_ts "\
        "$stim_file_reg "\
        "-stim_file $num_1 motion_demean_${which_task}.1D'[0]' -stim_base $num_1 -stim_label $num_1 roll "\
        "-stim_file $num_2 motion_demean_${which_task}.1D'[1]' -stim_base $num_2 -stim_label $num_2 pitch "\
        "-stim_file $num_3 motion_demean_${which_task}.1D'[2]' -stim_base $num_3 -stim_label $num_3 yaw "\
        "-stim_file $num_4 motion_demean_${which_task}.1D'[3]' -stim_base $num_4 -stim_label $num_4 dS "\
        "-stim_file $num_5 motion_demean_${which_task}.1D'[4]' -stim_base $num_5 -stim_label $num_5 dL "\
        "-stim_file $num_6 motion_demean_${which_task}.1D'[5]' -stim_base $num_6 -stim_label $num_6 dP "\
        "$glt_reg "\
        "-fout -tout -x1D X.${which_task}.xmat.1D -xjpeg X.${which_task}.jpg "\
        "-x1D_uncensored X.${which_task}.nocensor.xmat.1D "\
        "-fitts fitts.$subj.${which_task} "\
        "-errts errts.${subj}.${which_task} "\
        "-bucket stats.$subj.${which_task} "\
        "-cbucket cbucket.$subj.${which_task} "\
        "-mask full_mask.$subj+orig "\
        "-GOFORIT $n_goforit" > 3dDeconvolve_{$which_task}.csh

    chmod ug+x 3dDeconvolve_{$which_task}.csh

    ./3dDeconvolve_{$which_task}.csh |& tee out_3dDeconvolve_${which_task}.txt

    # -- use 3dTproject to project out regression matrix --
    3dTproject -polort 0 -input $scale_list                                                       \
               -censor motion_${subj}_{$which_task}_censor.1D -cenmode ZERO                      \
               -ort X.{$which_task}.nocensor.xmat.1D -prefix errts.${subj}.{$which_task}.tproject

# # if 3dDeconvolve fails, terminate the script
    if ( $status != 0 ) then
        echo '---------------------------------------'
        echo '** 3dDeconvolve error, failing...'
        echo '   (consider the file 3dDeconvolve.err)'
        exit
    endif


# # display any large pairwise correlations from the X-matrix
    1d_tool.py -show_cormat_warnings -infile X.{$which_task}.xmat.1D |& tee out.cormat_warn.txt

# # create an all_runs dataset to match the fitts, errts, etc.
#    ln -s $scale_list all_runs.$subj.{$which_task}.nii.gz
# mps 20200824 don't actually make this, only 1 run at a time anyway

# # --------------------------------------------------
# # create a temporal signal to noise ratio dataset 
# #    signal: if 'scale' BLOCK4, mean should be 100
# #    noise : compute standard deviation of errts
    3dTstat -overwrite -mean -prefix rm.signal.all {$scale_list}"[$ktrs]"
    3dTstat -overwrite -stdev -prefix rm.noise.all errts.${subj}.{$which_task}.tproject+orig"[$ktrs]"
    3dcalc -a rm.signal.all+orig                                                  \
           -b rm.noise.all+orig                                                   \
           -c full_mask.$subj+orig                                                \
           -expr 'c*a/b' -prefix TSNR.$subj.{$which_task} 

# # ---------------------------------------------------
# # compute and store GCOR (global correlation average)
# # (sum of squares of global mean of unit errts)
    3dTnorm -overwrite -norm2 -prefix rm.errts.unit errts.${subj}.{$which_task}.tproject+orig
    3dmaskave -quiet -mask full_mask.$subj+orig rm.errts.unit+orig                          \
              > gmean.errts.unit.{$which_task}.1D
    3dTstat -sos -prefix - gmean.errts.unit.{$which_task}.1D\' > out.gcor.{$which_task}.1D
    echo '-- GCOR = cat out.gcor.'${which_task}'.1D'

# ---------------------------------------------------
# compute correlation volume
# (per voxel: average correlation across masked brain)
# (now just dot product with average unit time series)
    3dcalc -overwrite -a rm.errts.unit+orig -b gmean.errts.unit.{$which_task}.1D \
        -expr 'a*b' -prefix rm.DP
    3dTstat -sum -prefix corr_brain.{$which_task} rm.DP+orig

# --------------------------------------------------------
# compute sum of non-baseline regressors from the X-matrix
# (use 1d_tool.py to get list of regressor colums)
    if ( $which_task == 'retCW' ) then
        set reg_cols = `1d_tool.py -infile X.retCW.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'retCCW' ) then
        set reg_cols = `1d_tool.py -infile X.retCCW.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'gamLoc' ) then
        set reg_cols = `1d_tool.py -infile X.gamLoc.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'ssLoc' ) then
        set reg_cols = `1d_tool.py -infile X.ssLoc.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'illLoc' ) then
        set reg_cols = `1d_tool.py -infile X.illLoc.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'LOCLoc' ) then
        set reg_cols = `1d_tool.py -infile X.LOCLoc.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'MTLoc' ) then
        set reg_cols = `1d_tool.py -infile X.MTLoc.nocensor.xmat.1D -show_indices_interest`
#    else if ( $which_task == 'retExp' ) then
#        set reg_cols = `1d_tool.py -infile X.retExp.nocensor.xmat.1D -show_indices_interest`
     else if ( $which_task == 'sizeHall_LL' ) then
        set reg_cols = `1d_tool.py -infile X.sizeHall_LL.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'sizeHall_UL' ) then
        set reg_cols = `1d_tool.py -infile X.sizeHall_UL.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'sizeNoHall_LL' ) then
        set reg_cols = `1d_tool.py -infile X.sizeNoHall_LL.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'sizeNoHall_UL' ) then
        set reg_cols = `1d_tool.py -infile X.sizeNoHall_UL.nocensor.xmat.1D -show_indices_interest`
    endif
    3dTstat -sum -prefix sum_ideal.{$which_task}.1D X.{$which_task}.nocensor.xmat.1D"[$reg_cols]"

# also, create a stimulus-only X-matrix, for easy review
    1dcat X.{$which_task}.nocensor.xmat.1D"[$reg_cols]" > X.{$which_task}.stim.xmat.1D

# ============================ blur estimation =============================
# compute blur estimates
    touch blur_est.$subj.{$which_task}.1D
    # start with empty file


# -- estimate blur for each run in epits --
    touch blur.epits.{$which_task}.1D

# restrict to uncensored TRs, per run
    foreach run ( $idx_runs )
        if ( $which_task == 'retCW' ) then
            set trs = `1d_tool.py -infile X.retCW.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'retCCW' ) then
            set trs = `1d_tool.py -infile X.retCCW.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'gamLoc' ) then
            set trs = `1d_tool.py -infile X.gamLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'ssLoc' ) then
            set trs = `1d_tool.py -infile X.ssLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'illLoc' ) then
            set trs = `1d_tool.py -infile X.illLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'LOCLoc' ) then
            set trs = `1d_tool.py -infile X.LOCLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'MTLoc' ) then
            set trs = `1d_tool.py -infile X.MTLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
#        else if ( $which_task == 'retExp' ) then
#            set trs = `1d_tool.py -infile X.retExp.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeHall_LL' ) then
            set trs = `1d_tool.py -infile X.sizeHall_LL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeHall_UL' ) then
            set trs = `1d_tool.py -infile X.sizeHall_UL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeNoHall_LL' ) then
            set trs = `1d_tool.py -infile X.sizeNoHall_LL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeNoHall_UL' ) then
            set trs = `1d_tool.py -infile X.sizeNoHall_UL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        endif

        if ( $trs == "" ) continue
        3dFWHMx -detrend -mask full_mask.$subj+orig                                     \
                -ACF files_ACF/out.3dFWHMx.ACF.epits{$which_task}.r$run.1D              \
                {$scale_list}"[$trs]" >> blur.epits.{$which_task}.1D
    end

# compute average FWHM blur (from every other row) and append
    if ( $which_task == 'retCW' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.retCW.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'retCCW' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.retCCW.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'gamLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.gamLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'ssLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.ssLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'illLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.illLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'LOCLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.LOCLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'MTLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.MTLoc.1D'{0..$(2)}'\'` )
#    else if ( $which_task == 'retExp' ) then
#        set blurs = ( `3dTstat -mean -prefix - blur.epits.retExp.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_LL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeHall_LL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_UL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeHall_UL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_LL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeNoHall_LL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_UL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeNoHall_UL.1D'{0..$(2)}'\'` )
    endif

    echo average epits FWHM blurs: $blurs
    echo "$blurs   # epits FWHM blur estimates" >> blur_est.$subj.{$which_task}.1D

# compute average ACF blur (from every other row) and append
    if ( $which_task == 'retCW' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.retCW.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'retCCW' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.retCCW.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'gamLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.gamLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'ssLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.ssLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'illLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.illLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'LOCLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.LOCLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'MTLoc' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.MTLoc.1D'{1..$(2)}'\'` )
#    else if ( $which_task == 'retExp' ) then
#        set blurs = ( `3dTstat -mean -prefix - blur.epits.retExp.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_LL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeHall_LL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_UL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeHall_UL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_LL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeNoHall_LL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_UL' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.sizeNoHall_UL.1D'{1..$(2)}'\'` )
    endif

    echo average epits ACF blurs: $blurs
    echo "$blurs   # epits ACF blur estimates" >> blur_est.$subj.{$which_task}.1D

# -- estimate blur for each run in errts --
    touch blur.errts.{$which_task}.1D

# # restrict to uncensored TRs, per run
    foreach run ( $idx_runs )
        if ( $which_task == 'retCW' ) then
            set trs = `1d_tool.py -infile X.retCW.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'retCCW' ) then
            set trs = `1d_tool.py -infile X.retCCW.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'gamLoc' ) then
            set trs = `1d_tool.py -infile X.gamLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'ssLoc' ) then
            set trs = `1d_tool.py -infile X.ssLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'illLoc' ) then
            set trs = `1d_tool.py -infile X.illLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'LOCLoc' ) then
            set trs = `1d_tool.py -infile X.LOCLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'MTLoc' ) then
            set trs = `1d_tool.py -infile X.MTLoc.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
#        else if ( $which_task == 'retExp' ) then
#            set trs = `1d_tool.py -infile X.retExp.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeHall_LL' ) then
            set trs = `1d_tool.py -infile X.sizeHall_LL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeHall_UL' ) then
            set trs = `1d_tool.py -infile X.sizeHall_UL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeNoHall_LL' ) then
            set trs = `1d_tool.py -infile X.sizeNoHall_LL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'sizeNoHall_UL' ) then
            set trs = `1d_tool.py -infile X.sizeNoHall_UL.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        endif

        if ( $trs == "" ) continue
        3dFWHMx -detrend -mask full_mask.$subj+orig                                             \
                -ACF files_ACF/out.3dFWHMx.ACF.errts.{$which_task}.r$run.1D                     \
                errts.${subj}.{$which_task}.tproject+orig"[$trs]" >> blur.errts.{$which_task}.1D
    end

# compute average FWHM blur (from every other row) and append
    if ( $which_task == 'retCW' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.retCW.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'retCCW' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.retCCW.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'gamLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.gamLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'ssLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.ssLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'illLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.illLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'LOCLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.LOCLoc.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'MTLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.MTLoc.1D'{0..$(2)}'\'` )
#    else if ( $which_task == 'retExp' ) then
#         set blurs = ( `3dTstat -mean -prefix - blur.errts.retExp.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_LL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeHall_LL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_UL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeHall_UL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_LL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeNoHall_LL.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_UL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeNoHall_UL.1D'{0..$(2)}'\'` )
    endif

     echo average errts FWHM blurs: $blurs
     echo "$blurs   # errts FWHM blur estimates" >> blur_est.$subj.{$which_task}.1D

# compute average ACF blur (from every other row) and append
    if ( $which_task == 'retCW' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.retCW.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'retCCW' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.retCCW.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'gamLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.gamLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'ssLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.ssLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'illLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.illLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'LOCLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.LOCLoc.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'MTLoc' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.MTLoc.1D'{1..$(2)}'\'` )
#    else if ( $which_task == 'retExp' ) then
#         set blurs = ( `3dTstat -mean -prefix - blur.errts.retExp.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_LL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeHall_LL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeHall_UL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeHall_UL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_LL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeNoHall_LL.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'sizeNoHall_UL' ) then
         set blurs = ( `3dTstat -mean -prefix - blur.errts.sizeNoHall_UL.1D'{1..$(2)}'\'` )
    endif

    echo average errts ACF blurs: $blurs
    echo "$blurs   # errts ACF blur estimates" >> blur_est.$subj.{$which_task}.1D

# add 3dClustSim results as attributes to any stats dset

# run Monte Carlo simulations using method 'ACF'
    set params = ( `grep ACF blur_est.$subj.{$which_task}.1D | tail -n 1` )
    3dClustSim -both -mask full_mask.$subj+orig -acf $params[1-3]            \
               -cmd 3dClustSim.ACF.{$which_task}.cmd -prefix files_ClustSim/ClustSim.ACF.{$which_task}
# run 3drefit to attach 3dClustSim results to stats
    set cmd = ( `cat 3dClustSim.ACF.{$which_task}.cmd` )
    $cmd stats.$subj.{$which_task}+orig


# ================== auto BLOCK4: generate review scripts ===================
    3dcalc -overwrite -prefix corr_brain.{$which_task}+orig -a corr_brain.{$which_task}+orig -expr 'a' -datum short
#    3dcalc -overwrite -prefix errts.${subj}.{$which_task}+orig -a errts.${subj}.{$which_task}+orig -expr 'a' -datum short
# mps 20200826 don't short the errts file, this is our data file of interest for the Ret task data
    3dcalc -overwrite -prefix errts.${subj}.{$which_task}.tproject+orig -a errts.${subj}.{$which_task}.tproject+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix fitts.${subj}.{$which_task}+orig -a fitts.${subj}.{$which_task}+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix TSNR.${subj}.{$which_task}+orig -a TSNR.${subj}.{$which_task}+orig -expr 'a' -datum short


    cp X.{$which_task}.xmat.1D X.xmat.1D # script below is stupid and has hard-coded assumption about this file...

    gen_ss_review_scripts.py -mot_limit 0.5                        \
        -uvar align_anat anat_SurfVol_ns_uni+orig                  \
        -uvar censor_dset motion_${subj}_{$which_task}_censor.1D   \
        -uvar enorm_dset motion_${subj}_{$which_task}_enorm.1D     \
        -uvar errts_dset errts.${subj}.{$which_task}.tproject+orig \
        -uvar final_anat anat_final.{$subj}+orig                   \
        -uvar final_view orig                                      \
        -uvar gcor_dset out.gcor.{$which_task}.1D                  \
        -uvar mask_dset full_mask.{$subj}+orig.HEAD                \
        -uvar motion_dset dfile_{$which_task}.1D                   \
        -uvar num_stim $n_cond                                     \
        -uvar outlier_dset outcount.r{$run}.1D               \
        -uvar stats_dset stats.{$subj}.{$which_task}+orig          \
        -uvar subj {$subj}                                         \
        -uvar sum_ideal sum_ideal.{$which_task}.1D                 \
        -uvar tcat_dset pb00.{$subj}.r01.tcat+orig                 \
        -uvar tsnr_dset TSNR.{$subj}.{$which_task}+orig            \
        -uvar volreg_dset pb02.{$subj}.r01.volreg+orig.HEAD        \
        -xmat_regress X.{$which_task}.xmat.1D                      \
        -xmat_uncensored X.{$which_task}.nocensor.xmat.1D          \
        -prefix {$which_task}                                      \
        -exit0

    # if the basic subject review script is here, run it
    # (want this to be the last text output)
    if ( -e {$which_task}@ss_review_basic ) then
        echo "executing $which_task@ss_review_basic"
        ./{$which_task}@ss_review_basic |& tee out.ss_review.$subj.{$which_task}.txt
    else
        echo "did not find $which_task@ss_review_basic"
    endif

    rm X.xmat.1D # clean this up

# ========================== auto BLOCK4: finalize ==========================
end

# generate a review script for the unprocessed EPI data
gen_epi_review.py -script @epi_review.$subj \
    -dsets pb00.$subj.r*.tcat+orig.HEAD

# remove temporary files
\rm -f rm.*


# return to parent directory
cd ..

echo "execution finished: `date`"